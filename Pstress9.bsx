'{$STAMP BS2sx}
'{$PBASIC 2.5}
'________________________________________________________________
' Investigate Stress GSR Biofeedback demonstration
' May 2008 by Peter Reintjes
' Museum of Life and Science, Durham, NC
'
' Original version of this code from
' Harmony and Health GSR / Bio Feedback display Mar '07
' by Brian Hambleton of the Ontario Science Center
'_________________________________________________________________

'Hardware interface with the 7219:
  DATA_n      CON  7  'Bits are shifted out this pin # to 7219.
  CLK         CON  5  'Data valid on rising edge of this clock pin.
  Load        CON  6  'Tells 7219 to transfer data to LEDs.
  LoadPulse   CON  5  'Pulse width for loading MAX7218

' To control attributes of the display, write the register
' address (brite) followed by the data (15 for max brightness)

  max_data    VAR  Word ' Word to be sent to MAX7219.
  bp          VAR  Byte ' bit position counter
  decode      CON  9   ' BCD decoding on(1) or off(0)
  brite       CON  10   ' Intensity 0-15
  scan        CON  11   ' Number of digits
  switch      CON  12   ' LED Power on/off

'__________________________________________________________________
'Interface with the GSR2

  PulseType       CON   0    ' Type of Measurement 0-to-[1] or 1-to-[0]

  gsr             VAR Word   ' GSR pulse length
  prevGSR         VAR Word   ' previous GSR pulse length

  lower           VAR Word   ' How many readings were Higher
  higher          VAR Word   ' and how many were Lower
  threshold       CON  5     ' Minimum difference to register a change

  index    VAR  Byte     'FOR LOOP index for Main loop
  index2   VAR  Byte     'FOR LOOP index (in subroutines)
  initial  VAR  Byte     'True for the first GSR reading of a user
  idle     VAR  Byte

  Delay    VAR Byte  ' Delay value for LED ring speed
  DecDelta    VAR Byte
  IncDelta    VAR Byte

  tempa    VAR Word
  tempb    VAR Word

  FastDisp  CON 1   ' Minimum delay (fastest rotation of LEDs)
  SlowDisp  CON 96  ' Maximum delay (slowest rotation of LEDs)

  OUTS = 0        'All output latches low.
  DIRS = $FFFF    'All pins to output.
  initial = 1     'Need to do GSR Calibration for new User

  GOSUB InitializeMax

' ====================== MAIN PROGRAM LOOP ==========================
' Initialize the MAX7219 and demonstrate several different speeds.

  FOR index = 0 TO 4
     LOOKUP index, [32,20,10,5,2], Delay
     GOSUB Spin
  NEXT

Main:
  GOSUB ComputeDelay
  bp=1
  DO

   FOR index = 1 TO 8                    ' FROM digit 1 to digit 8.
    SHIFTOUT DATA_n,CLK,MSBFIRST,[index] ' Select Digit
    SHIFTOUT DATA_n,CLK,MSBFIRST,[bp]    ' LED ON
    PULSOUT Load,LoadPulse

    GOSUB GetMedian
    PAUSE Delay

    SHIFTOUT DATA_n,CLK,MSBFIRST,[index] ' Select Digit
    SHIFTOUT DATA_n,CLK,MSBFIRST,[0]     ' LED OFF
    PULSOUT Load,LoadPulse
   NEXT        ' index
   bp = bp << 1
  LOOP UNTIL bp = 0

GOTO Main  ' Main Program loops forever


	GOSUB GetMedian
  RETURN

 ComputeDelay:

	IF ( initial = 1 ) THEN
                GOSUB GetMedian
                GOSUB GetMedian
		initial = 0
		Delay = FastDisp
		RETURN
	ENDIF

	'  Scale the Increment According to the current speed
	IF (DELAY < 8) THEN
		IncDelta = 1
		DecDelta = 1
	ELSEIF (Delay < 14) THEN
	        IncDelta = 2
		DecDelta = 2
	ELSEIF (Delay < 23)  THEN
		IncDelta = 4
		DecDelta = 3
	ELSE
		IncDelta = 8
		DecDelta = 6
	ENDIF

	IF ( lower > higher + threshold ) THEN  Delay = Delay + IncDelta
	IF ( higher < lower + threshold ) THEN  Delay = Delay - DecDelta

        lower = 0     ' RESET THE COUNTERS
        higher = 0
	
	IF (Delay < FastDisp OR Delay > 10000 ) THEN   ' Keep Delay withing Range
		Delay = FastDisp
	ELSEIF (Delay > SlowDisp) THEN
		Delay = SlowDisp
	ENDIF
  RETURN


' Initialize the MAX7219 from a list of ( REGISTER : VALUE ) pairs
' Digits 0-(7), max brightness (15), no BCD decoding(0), LED power ON(1)
' The load pulse comes after we shift 16 bits into the MAX7219

 InitializeMax:

  FOR index2 = 0 TO 7    'Retrieve 8 items from table.
     LOOKUP index2,[scan,7,brite,15,decode,0,switch,1],max_data
     SHIFTOUT DATA_n,CLK,MSBFIRST,[max_data]
     IF index2.BIT0 = 1 THEN PULSOUT Load,LoadPulse
  NEXT

 RETURN

 Spin:
    bp=1
    DO
      FOR index2 = 0 TO 8    'Work from digit 1 down to digit 8.

       SHIFTOUT DATA_n,CLK,MSBFIRST,[index2] ' Digit position
       SHIFTOUT DATA_n,CLK,MSBFIRST,[bp]     ' Select Segment
       PULSOUT Load,LoadPulse

       PAUSE Delay

       SHIFTOUT DATA_n,CLK,MSBFIRST,[index2] ' Digit position
       SHIFTOUT DATA_n,CLK,MSBFIRST,[0]      ' Clear Segment(s)
       PULSOUT Load,LoadPulse                ' Load the display

      NEXT        ' index2
    bp = bp << 1
  LOOP UNTIL bp = 0
  RETURN

  Blank:
   FOR index2 = 1 TO 8                       'From digit 1 to digit 8.
       SHIFTOUT DATA_n,CLK,MSBFIRST,[index2] 'Send digit position.
       SHIFTOUT DATA_n,CLK,MSBFIRST,[0]      'Send the digit.
       PULSOUT Load,LoadPulse                'And load the display.
   NEXT        ' index2
  RETURN

' Return the median of three readings and keep track of how
' often a reading registers an increase verses a decrease in GSR.
'
' ComputeDelay will use these statistics and reset the counters
'

 GetMedian:
	prevGSR = gsr

 ZeroReading:	
	PULSIN 1,PulseType,tempa
	PULSIN 1,PulseType,gsr
	PULSIN 1,PulseType,tempb

	idle = idle + 1
	IF (idle > 30) THEN  ' ~10 sec idle resets everything
             initial = 1
             idle = 0
             gsr = 0
             prevGSR = 0
             GOSUB Blank      ' and turns off the LED display
	     GOTO ZeroReading
        ENDIF

	IF (tempa = 0 OR tempa > 255 OR tempb = 0 OR tempb > 255 OR gsr = 0 OR gsr > 255) THEN ZeroReading

	' WE GOT THREE GOOD VALUES, NOW COMPUTE THE MEDIAN

	IF gsr > tempa THEN
		IF gsr > tempb THEN
			IF tempa > tempb THEN
				gsr = tempa
			ELSE
				gsr = tempb
			ENDIF
		ENDIF
	ELSE  ' gsr < tempa
		IF gsr < tempb THEN
			IF tempa < tempb THEN
				gsr = tempa
			ELSE
				gsr = tempb
			ENDIF
		ENDIF
	ENDIF

	
	IF     ( prevGSR = 0 ) THEN
		prevGSR = gsr
	ELSEIF ( gsr > prevGSR ) THEN
		lower = lower + 1
	ELSEIF ( gsr < prevGSR ) THEN
		higher = higher + 1
        ENDIF

 RETURN
